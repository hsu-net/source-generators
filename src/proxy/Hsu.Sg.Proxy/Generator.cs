// ReSharper disable RedundantNameQualifier
using Microsoft.CodeAnalysis;

namespace Hsu.Sg.Proxy;
#pragma warning disable S125

/// <summary>
///     To generate proxy object.
/// </summary>
[Generator(LanguageNames.CSharp)]
public partial class Generator : IIncrementalGenerator
{
    private IncrementalValueProvider<ImmutableArray<AdditionalText>> _additionalTypes;
    
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        #if PROXY_GEN_DEBUG
        if (!System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Launch();
        #endif

        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(PostInitializationOutput);
        
        // Filter classes annotated with the [Proxy] attribute. Only filtered Syntax Nodes can trigger code generation.
        /*
        * Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax
        *   - Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax
        *   - Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax
        *   - Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax
        *   - Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax
        */

        _additionalTypes = context
            .AdditionalTextsProvider
            .Where(x => x.Path.EndsWith(".cs"))
            .Collect();
        
        var sources = context
            .SyntaxProvider
            .CreateSyntaxProvider((s, _) => s is TypeDeclarationSyntax, TypeDeclarationTransform)
            .Where(t => t is not null)
            .Select((x, _) => x!)
            .Collect()
            .Combine(_additionalTypes);

        var collect = context.CompilationProvider.Combine(sources);
        // Generate the source code.
        context.RegisterSourceOutput(collect, GenerateCode);
    }

    private static void GenerateCode(SourceProductionContext ctx, (Compilation Compilation, (ImmutableArray<TypeSource> Syntaxes, ImmutableArray<AdditionalText> Additions) Context) combined)
    {
        var comment = SyntaxFactory
            .ParseLeadingTrivia("// <auto-generated/>")
            .Add(SyntaxFactory.CarriageReturnLineFeed);

        var types = combined.Context.Syntaxes;
        if (!combined.Context.Additions.IsEmpty)
        {
            var generated = ParseAdditionalFiles(combined.Compilation, combined.Context.Additions);
            if (generated.Count > 0)
            {
                types = types.AddRange(generated);
            }
        }
        
        var groups = types.GroupBy(x => x.Syntax.Identifier.Text);

        foreach(var group in groups)
        {
            var counter = 0;
            var merged = SyntaxFactory.CompilationUnit();
            TypeDeclarationSyntax type = null!;
            BaseNamespaceDeclarationSyntax nd = null!;
            string typeIdentifier=null!;
            
            foreach(var item in group)
            {
                var root = item.Syntax.SyntaxTree.GetRoot();
                if (root is not CompilationUnitSyntax compilation) continue;

                var compile = combined.Compilation;
                if (!combined.Compilation.ContainsSyntaxTree(root.SyntaxTree))
                {
                    compile = combined.Compilation.AddSyntaxTrees(root.SyntaxTree);
                }
                
                // We need to get semantic model of the class to retrieve metadata.
                var semanticModel = compile.GetSemanticModel(root.SyntaxTree);

                // Symbols allow us to get the compile-time information.
                if (semanticModel.GetDeclaredSymbol(item.Syntax) is not { } symbol) continue;
                typeIdentifier = symbol.MetadataName;

                var rewriter = new ProxyGenSyntaxRewriter(semanticModel, item.Syntax, item.Attribute);
                if (rewriter.Visit(item.Syntax) is not TypeDeclarationSyntax node || rewriter.Counter == 0) continue;
                counter += rewriter.Counter;

                foreach(var diagnostic in rewriter.Diagnostics)
                {
                    ctx.ReportDiagnostic(diagnostic);
                }

                if (compilation.Usings.Count > 0)
                {
                    foreach(var @using in compilation.Usings)
                    {
                        if (merged.Usings.Any(a => a.Name==null || a.Name?.ToFullString() == @using.Name?.ToFullString())) continue;
                        merged = merged.AddUsings(@using.WithoutTrivia());
                    }
                }

                BaseNamespaceDeclarationSyntax ns = root
                    .DescendantNodes()
                    .OfType<BaseNamespaceDeclarationSyntax>()
                    .First();
                TypeDeclarationSyntax t = node
                    .RemoveNodes(node
                            .DescendantNodes()
                            .OfType<TypeDeclarationSyntax>(),
                        SyntaxRemoveOptions.KeepEndOfLine)!;

                // ReSharper disable once ConditionIsAlwaysTrueOrFalseAccordingToNullableAPIContract
                if (type == null)
                {
                    type = t
                        .WithoutTrivia()
                        .WithMembers(SyntaxFactory.List<MemberDeclarationSyntax>());
                    
                    nd = ns
                        .WithoutTrivia()
                        .WithMembers(SyntaxFactory.List<MemberDeclarationSyntax>())
                        .WithUsings(SyntaxFactory.List<UsingDirectiveSyntax>());
                }

                if (ns.Usings.Count > 0)
                {
                    foreach(var @using in ns.Usings)
                    {
                        if (nd.Usings.Any(a => a.Name==null || a.Name?.ToFullString() == @using.Name?.ToFullString())) continue;
                        nd = nd.AddUsings(@using.WithoutTrivia());
                    }
                }

                type = type.AddMembers(t.Members.Where(x=>!x.IsModifier(SyntaxKind.PrivateKeyword)).ToArray());
            }

            if (counter == 0) continue;
            var st = group.First();
            type = TypeDeclaration(type, st);
            merged = CompilationUnitMerged(merged, nd, type, comment, counter, st);
            var formatted = CompilationUnitFormat(merged);
            ctx.AddSource($"{nd.Name.ToFullString()}.{typeIdentifier}.{GenSuffix}.g.cs",
                SourceText.From(formatted.ToFullString(), Encoding.UTF8));
        }
    }

    private static TypeSource? TypeDeclarationTransform(GeneratorSyntaxContext ctx, CancellationToken cancellation)
    {
        cancellation.ThrowIfCancellationRequested();
        var typeDeclarationSyntax = (TypeDeclarationSyntax)ctx.Node;
        return TypeDeclarationTransform(typeDeclarationSyntax, ctx.SemanticModel);
    }

    private static TypeSource? TypeDeclarationTransform(TypeDeclarationSyntax typeDeclarationSyntax,SemanticModel semanticModel)
    {
        if(!Metadata.TryGet(typeDeclarationSyntax,semanticModel,out var metadata) || metadata==null) return null;
        return new TypeSource(typeDeclarationSyntax, metadata);
    }
}
